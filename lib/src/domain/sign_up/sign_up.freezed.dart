// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'sign_up.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$PasswordStrengthTearOff {
  const _$PasswordStrengthTearOff();

  GoodPasswordStrength good() {
    return const GoodPasswordStrength();
  }

  StrongPasswordStrength strong() {
    return const StrongPasswordStrength();
  }

  VeryStrongPasswordStrength veryStrong() {
    return const VeryStrongPasswordStrength();
  }

  WeakPasswordStrength weak() {
    return const WeakPasswordStrength();
  }
}

// ignore: unused_element
const $PasswordStrength = _$PasswordStrengthTearOff();

mixin _$PasswordStrength {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
    @required Result weak(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result good(),
    Result strong(),
    Result veryStrong(),
    Result weak(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
    @required Result weak(WeakPasswordStrength value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    Result weak(WeakPasswordStrength value),
    @required Result orElse(),
  });
}

abstract class $PasswordStrengthCopyWith<$Res> {
  factory $PasswordStrengthCopyWith(
          PasswordStrength value, $Res Function(PasswordStrength) then) =
      _$PasswordStrengthCopyWithImpl<$Res>;
}

class _$PasswordStrengthCopyWithImpl<$Res>
    implements $PasswordStrengthCopyWith<$Res> {
  _$PasswordStrengthCopyWithImpl(this._value, this._then);

  final PasswordStrength _value;
  // ignore: unused_field
  final $Res Function(PasswordStrength) _then;
}

abstract class $GoodPasswordStrengthCopyWith<$Res> {
  factory $GoodPasswordStrengthCopyWith(GoodPasswordStrength value,
          $Res Function(GoodPasswordStrength) then) =
      _$GoodPasswordStrengthCopyWithImpl<$Res>;
}

class _$GoodPasswordStrengthCopyWithImpl<$Res>
    extends _$PasswordStrengthCopyWithImpl<$Res>
    implements $GoodPasswordStrengthCopyWith<$Res> {
  _$GoodPasswordStrengthCopyWithImpl(
      GoodPasswordStrength _value, $Res Function(GoodPasswordStrength) _then)
      : super(_value, (v) => _then(v as GoodPasswordStrength));

  @override
  GoodPasswordStrength get _value => super._value as GoodPasswordStrength;
}

class _$GoodPasswordStrength implements GoodPasswordStrength {
  const _$GoodPasswordStrength();

  @override
  String toString() {
    return 'PasswordStrength.good()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is GoodPasswordStrength);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
    @required Result weak(),
  }) {
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    assert(weak != null);
    return good();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result good(),
    Result strong(),
    Result veryStrong(),
    Result weak(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (good != null) {
      return good();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
    @required Result weak(WeakPasswordStrength value),
  }) {
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    assert(weak != null);
    return good(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    Result weak(WeakPasswordStrength value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (good != null) {
      return good(this);
    }
    return orElse();
  }
}

abstract class GoodPasswordStrength implements PasswordStrength {
  const factory GoodPasswordStrength() = _$GoodPasswordStrength;
}

abstract class $StrongPasswordStrengthCopyWith<$Res> {
  factory $StrongPasswordStrengthCopyWith(StrongPasswordStrength value,
          $Res Function(StrongPasswordStrength) then) =
      _$StrongPasswordStrengthCopyWithImpl<$Res>;
}

class _$StrongPasswordStrengthCopyWithImpl<$Res>
    extends _$PasswordStrengthCopyWithImpl<$Res>
    implements $StrongPasswordStrengthCopyWith<$Res> {
  _$StrongPasswordStrengthCopyWithImpl(StrongPasswordStrength _value,
      $Res Function(StrongPasswordStrength) _then)
      : super(_value, (v) => _then(v as StrongPasswordStrength));

  @override
  StrongPasswordStrength get _value => super._value as StrongPasswordStrength;
}

class _$StrongPasswordStrength implements StrongPasswordStrength {
  const _$StrongPasswordStrength();

  @override
  String toString() {
    return 'PasswordStrength.strong()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is StrongPasswordStrength);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
    @required Result weak(),
  }) {
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    assert(weak != null);
    return strong();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result good(),
    Result strong(),
    Result veryStrong(),
    Result weak(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (strong != null) {
      return strong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
    @required Result weak(WeakPasswordStrength value),
  }) {
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    assert(weak != null);
    return strong(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    Result weak(WeakPasswordStrength value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (strong != null) {
      return strong(this);
    }
    return orElse();
  }
}

abstract class StrongPasswordStrength implements PasswordStrength {
  const factory StrongPasswordStrength() = _$StrongPasswordStrength;
}

abstract class $VeryStrongPasswordStrengthCopyWith<$Res> {
  factory $VeryStrongPasswordStrengthCopyWith(VeryStrongPasswordStrength value,
          $Res Function(VeryStrongPasswordStrength) then) =
      _$VeryStrongPasswordStrengthCopyWithImpl<$Res>;
}

class _$VeryStrongPasswordStrengthCopyWithImpl<$Res>
    extends _$PasswordStrengthCopyWithImpl<$Res>
    implements $VeryStrongPasswordStrengthCopyWith<$Res> {
  _$VeryStrongPasswordStrengthCopyWithImpl(VeryStrongPasswordStrength _value,
      $Res Function(VeryStrongPasswordStrength) _then)
      : super(_value, (v) => _then(v as VeryStrongPasswordStrength));

  @override
  VeryStrongPasswordStrength get _value =>
      super._value as VeryStrongPasswordStrength;
}

class _$VeryStrongPasswordStrength implements VeryStrongPasswordStrength {
  const _$VeryStrongPasswordStrength();

  @override
  String toString() {
    return 'PasswordStrength.veryStrong()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is VeryStrongPasswordStrength);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
    @required Result weak(),
  }) {
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    assert(weak != null);
    return veryStrong();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result good(),
    Result strong(),
    Result veryStrong(),
    Result weak(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (veryStrong != null) {
      return veryStrong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
    @required Result weak(WeakPasswordStrength value),
  }) {
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    assert(weak != null);
    return veryStrong(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    Result weak(WeakPasswordStrength value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (veryStrong != null) {
      return veryStrong(this);
    }
    return orElse();
  }
}

abstract class VeryStrongPasswordStrength implements PasswordStrength {
  const factory VeryStrongPasswordStrength() = _$VeryStrongPasswordStrength;
}

abstract class $WeakPasswordStrengthCopyWith<$Res> {
  factory $WeakPasswordStrengthCopyWith(WeakPasswordStrength value,
          $Res Function(WeakPasswordStrength) then) =
      _$WeakPasswordStrengthCopyWithImpl<$Res>;
}

class _$WeakPasswordStrengthCopyWithImpl<$Res>
    extends _$PasswordStrengthCopyWithImpl<$Res>
    implements $WeakPasswordStrengthCopyWith<$Res> {
  _$WeakPasswordStrengthCopyWithImpl(
      WeakPasswordStrength _value, $Res Function(WeakPasswordStrength) _then)
      : super(_value, (v) => _then(v as WeakPasswordStrength));

  @override
  WeakPasswordStrength get _value => super._value as WeakPasswordStrength;
}

class _$WeakPasswordStrength implements WeakPasswordStrength {
  const _$WeakPasswordStrength();

  @override
  String toString() {
    return 'PasswordStrength.weak()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WeakPasswordStrength);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
    @required Result weak(),
  }) {
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    assert(weak != null);
    return weak();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result good(),
    Result strong(),
    Result veryStrong(),
    Result weak(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (weak != null) {
      return weak();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
    @required Result weak(WeakPasswordStrength value),
  }) {
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    assert(weak != null);
    return weak(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    Result weak(WeakPasswordStrength value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (weak != null) {
      return weak(this);
    }
    return orElse();
  }
}

abstract class WeakPasswordStrength implements PasswordStrength {
  const factory WeakPasswordStrength() = _$WeakPasswordStrength;
}

class _$EmailValidationErrorTearOff {
  const _$EmailValidationErrorTearOff();

  EmptyEmailAdress empty() {
    return const EmptyEmailAdress();
  }

  InvalidEmailAdress invalid() {
    return const InvalidEmailAdress();
  }
}

// ignore: unused_element
const $EmailValidationError = _$EmailValidationErrorTearOff();

mixin _$EmailValidationError {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result invalid(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result invalid(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyEmailAdress value),
    @required Result invalid(InvalidEmailAdress value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyEmailAdress value),
    Result invalid(InvalidEmailAdress value),
    @required Result orElse(),
  });
}

abstract class $EmailValidationErrorCopyWith<$Res> {
  factory $EmailValidationErrorCopyWith(EmailValidationError value,
          $Res Function(EmailValidationError) then) =
      _$EmailValidationErrorCopyWithImpl<$Res>;
}

class _$EmailValidationErrorCopyWithImpl<$Res>
    implements $EmailValidationErrorCopyWith<$Res> {
  _$EmailValidationErrorCopyWithImpl(this._value, this._then);

  final EmailValidationError _value;
  // ignore: unused_field
  final $Res Function(EmailValidationError) _then;
}

abstract class $EmptyEmailAdressCopyWith<$Res> {
  factory $EmptyEmailAdressCopyWith(
          EmptyEmailAdress value, $Res Function(EmptyEmailAdress) then) =
      _$EmptyEmailAdressCopyWithImpl<$Res>;
}

class _$EmptyEmailAdressCopyWithImpl<$Res>
    extends _$EmailValidationErrorCopyWithImpl<$Res>
    implements $EmptyEmailAdressCopyWith<$Res> {
  _$EmptyEmailAdressCopyWithImpl(
      EmptyEmailAdress _value, $Res Function(EmptyEmailAdress) _then)
      : super(_value, (v) => _then(v as EmptyEmailAdress));

  @override
  EmptyEmailAdress get _value => super._value as EmptyEmailAdress;
}

class _$EmptyEmailAdress implements EmptyEmailAdress {
  const _$EmptyEmailAdress();

  @override
  String toString() {
    return 'EmailValidationError.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptyEmailAdress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result invalid(),
  }) {
    assert(empty != null);
    assert(invalid != null);
    return empty();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result invalid(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyEmailAdress value),
    @required Result invalid(InvalidEmailAdress value),
  }) {
    assert(empty != null);
    assert(invalid != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyEmailAdress value),
    Result invalid(InvalidEmailAdress value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyEmailAdress implements EmailValidationError {
  const factory EmptyEmailAdress() = _$EmptyEmailAdress;
}

abstract class $InvalidEmailAdressCopyWith<$Res> {
  factory $InvalidEmailAdressCopyWith(
          InvalidEmailAdress value, $Res Function(InvalidEmailAdress) then) =
      _$InvalidEmailAdressCopyWithImpl<$Res>;
}

class _$InvalidEmailAdressCopyWithImpl<$Res>
    extends _$EmailValidationErrorCopyWithImpl<$Res>
    implements $InvalidEmailAdressCopyWith<$Res> {
  _$InvalidEmailAdressCopyWithImpl(
      InvalidEmailAdress _value, $Res Function(InvalidEmailAdress) _then)
      : super(_value, (v) => _then(v as InvalidEmailAdress));

  @override
  InvalidEmailAdress get _value => super._value as InvalidEmailAdress;
}

class _$InvalidEmailAdress implements InvalidEmailAdress {
  const _$InvalidEmailAdress();

  @override
  String toString() {
    return 'EmailValidationError.invalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidEmailAdress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result invalid(),
  }) {
    assert(empty != null);
    assert(invalid != null);
    return invalid();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result invalid(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalid != null) {
      return invalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyEmailAdress value),
    @required Result invalid(InvalidEmailAdress value),
  }) {
    assert(empty != null);
    assert(invalid != null);
    return invalid(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyEmailAdress value),
    Result invalid(InvalidEmailAdress value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalid != null) {
      return invalid(this);
    }
    return orElse();
  }
}

abstract class InvalidEmailAdress implements EmailValidationError {
  const factory InvalidEmailAdress() = _$InvalidEmailAdress;
}

class _$NameValidationErrorTearOff {
  const _$NameValidationErrorTearOff();

  EmptyName empty() {
    return const EmptyName();
  }

  NameTooLong long() {
    return const NameTooLong();
  }

  NameTooShort short() {
    return const NameTooShort();
  }
}

// ignore: unused_element
const $NameValidationError = _$NameValidationErrorTearOff();

mixin _$NameValidationError {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result long(),
    @required Result short(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result long(),
    Result short(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyName value),
    @required Result long(NameTooLong value),
    @required Result short(NameTooShort value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyName value),
    Result long(NameTooLong value),
    Result short(NameTooShort value),
    @required Result orElse(),
  });
}

abstract class $NameValidationErrorCopyWith<$Res> {
  factory $NameValidationErrorCopyWith(
          NameValidationError value, $Res Function(NameValidationError) then) =
      _$NameValidationErrorCopyWithImpl<$Res>;
}

class _$NameValidationErrorCopyWithImpl<$Res>
    implements $NameValidationErrorCopyWith<$Res> {
  _$NameValidationErrorCopyWithImpl(this._value, this._then);

  final NameValidationError _value;
  // ignore: unused_field
  final $Res Function(NameValidationError) _then;
}

abstract class $EmptyNameCopyWith<$Res> {
  factory $EmptyNameCopyWith(EmptyName value, $Res Function(EmptyName) then) =
      _$EmptyNameCopyWithImpl<$Res>;
}

class _$EmptyNameCopyWithImpl<$Res>
    extends _$NameValidationErrorCopyWithImpl<$Res>
    implements $EmptyNameCopyWith<$Res> {
  _$EmptyNameCopyWithImpl(EmptyName _value, $Res Function(EmptyName) _then)
      : super(_value, (v) => _then(v as EmptyName));

  @override
  EmptyName get _value => super._value as EmptyName;
}

class _$EmptyName implements EmptyName {
  const _$EmptyName();

  @override
  String toString() {
    return 'NameValidationError.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptyName);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result long(),
    @required Result short(),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return empty();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result long(),
    Result short(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyName value),
    @required Result long(NameTooLong value),
    @required Result short(NameTooShort value),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyName value),
    Result long(NameTooLong value),
    Result short(NameTooShort value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyName implements NameValidationError {
  const factory EmptyName() = _$EmptyName;
}

abstract class $NameTooLongCopyWith<$Res> {
  factory $NameTooLongCopyWith(
          NameTooLong value, $Res Function(NameTooLong) then) =
      _$NameTooLongCopyWithImpl<$Res>;
}

class _$NameTooLongCopyWithImpl<$Res>
    extends _$NameValidationErrorCopyWithImpl<$Res>
    implements $NameTooLongCopyWith<$Res> {
  _$NameTooLongCopyWithImpl(
      NameTooLong _value, $Res Function(NameTooLong) _then)
      : super(_value, (v) => _then(v as NameTooLong));

  @override
  NameTooLong get _value => super._value as NameTooLong;
}

class _$NameTooLong implements NameTooLong {
  const _$NameTooLong();

  @override
  String toString() {
    return 'NameValidationError.long()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NameTooLong);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result long(),
    @required Result short(),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return long();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result long(),
    Result short(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (long != null) {
      return long();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyName value),
    @required Result long(NameTooLong value),
    @required Result short(NameTooShort value),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return long(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyName value),
    Result long(NameTooLong value),
    Result short(NameTooShort value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (long != null) {
      return long(this);
    }
    return orElse();
  }
}

abstract class NameTooLong implements NameValidationError {
  const factory NameTooLong() = _$NameTooLong;
}

abstract class $NameTooShortCopyWith<$Res> {
  factory $NameTooShortCopyWith(
          NameTooShort value, $Res Function(NameTooShort) then) =
      _$NameTooShortCopyWithImpl<$Res>;
}

class _$NameTooShortCopyWithImpl<$Res>
    extends _$NameValidationErrorCopyWithImpl<$Res>
    implements $NameTooShortCopyWith<$Res> {
  _$NameTooShortCopyWithImpl(
      NameTooShort _value, $Res Function(NameTooShort) _then)
      : super(_value, (v) => _then(v as NameTooShort));

  @override
  NameTooShort get _value => super._value as NameTooShort;
}

class _$NameTooShort implements NameTooShort {
  const _$NameTooShort();

  @override
  String toString() {
    return 'NameValidationError.short()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NameTooShort);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result long(),
    @required Result short(),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return short();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result long(),
    Result short(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (short != null) {
      return short();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyName value),
    @required Result long(NameTooLong value),
    @required Result short(NameTooShort value),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return short(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyName value),
    Result long(NameTooLong value),
    Result short(NameTooShort value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (short != null) {
      return short(this);
    }
    return orElse();
  }
}

abstract class NameTooShort implements NameValidationError {
  const factory NameTooShort() = _$NameTooShort;
}

class _$PasswordValidationErrorTearOff {
  const _$PasswordValidationErrorTearOff();

  PasswordConfirmationError confirmationFailed() {
    return const PasswordConfirmationError();
  }

  EmptyPasswordError empty() {
    return const EmptyPasswordError();
  }

  PasswordTooLogError tooLong() {
    return const PasswordTooLogError();
  }

  PasswordTooShortError tooShort() {
    return const PasswordTooShortError();
  }
}

// ignore: unused_element
const $PasswordValidationError = _$PasswordValidationErrorTearOff();

mixin _$PasswordValidationError {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  });
}

abstract class $PasswordValidationErrorCopyWith<$Res> {
  factory $PasswordValidationErrorCopyWith(PasswordValidationError value,
          $Res Function(PasswordValidationError) then) =
      _$PasswordValidationErrorCopyWithImpl<$Res>;
}

class _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $PasswordValidationErrorCopyWith<$Res> {
  _$PasswordValidationErrorCopyWithImpl(this._value, this._then);

  final PasswordValidationError _value;
  // ignore: unused_field
  final $Res Function(PasswordValidationError) _then;
}

abstract class $PasswordConfirmationErrorCopyWith<$Res> {
  factory $PasswordConfirmationErrorCopyWith(PasswordConfirmationError value,
          $Res Function(PasswordConfirmationError) then) =
      _$PasswordConfirmationErrorCopyWithImpl<$Res>;
}

class _$PasswordConfirmationErrorCopyWithImpl<$Res>
    extends _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $PasswordConfirmationErrorCopyWith<$Res> {
  _$PasswordConfirmationErrorCopyWithImpl(PasswordConfirmationError _value,
      $Res Function(PasswordConfirmationError) _then)
      : super(_value, (v) => _then(v as PasswordConfirmationError));

  @override
  PasswordConfirmationError get _value =>
      super._value as PasswordConfirmationError;
}

class _$PasswordConfirmationError implements PasswordConfirmationError {
  const _$PasswordConfirmationError();

  @override
  String toString() {
    return 'PasswordValidationError.confirmationFailed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PasswordConfirmationError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return confirmationFailed();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (confirmationFailed != null) {
      return confirmationFailed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return confirmationFailed(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (confirmationFailed != null) {
      return confirmationFailed(this);
    }
    return orElse();
  }
}

abstract class PasswordConfirmationError implements PasswordValidationError {
  const factory PasswordConfirmationError() = _$PasswordConfirmationError;
}

abstract class $EmptyPasswordErrorCopyWith<$Res> {
  factory $EmptyPasswordErrorCopyWith(
          EmptyPasswordError value, $Res Function(EmptyPasswordError) then) =
      _$EmptyPasswordErrorCopyWithImpl<$Res>;
}

class _$EmptyPasswordErrorCopyWithImpl<$Res>
    extends _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $EmptyPasswordErrorCopyWith<$Res> {
  _$EmptyPasswordErrorCopyWithImpl(
      EmptyPasswordError _value, $Res Function(EmptyPasswordError) _then)
      : super(_value, (v) => _then(v as EmptyPasswordError));

  @override
  EmptyPasswordError get _value => super._value as EmptyPasswordError;
}

class _$EmptyPasswordError implements EmptyPasswordError {
  const _$EmptyPasswordError();

  @override
  String toString() {
    return 'PasswordValidationError.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptyPasswordError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return empty();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyPasswordError implements PasswordValidationError {
  const factory EmptyPasswordError() = _$EmptyPasswordError;
}

abstract class $PasswordTooLogErrorCopyWith<$Res> {
  factory $PasswordTooLogErrorCopyWith(
          PasswordTooLogError value, $Res Function(PasswordTooLogError) then) =
      _$PasswordTooLogErrorCopyWithImpl<$Res>;
}

class _$PasswordTooLogErrorCopyWithImpl<$Res>
    extends _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $PasswordTooLogErrorCopyWith<$Res> {
  _$PasswordTooLogErrorCopyWithImpl(
      PasswordTooLogError _value, $Res Function(PasswordTooLogError) _then)
      : super(_value, (v) => _then(v as PasswordTooLogError));

  @override
  PasswordTooLogError get _value => super._value as PasswordTooLogError;
}

class _$PasswordTooLogError implements PasswordTooLogError {
  const _$PasswordTooLogError();

  @override
  String toString() {
    return 'PasswordValidationError.tooLong()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PasswordTooLogError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return tooLong();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooLong != null) {
      return tooLong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return tooLong(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooLong != null) {
      return tooLong(this);
    }
    return orElse();
  }
}

abstract class PasswordTooLogError implements PasswordValidationError {
  const factory PasswordTooLogError() = _$PasswordTooLogError;
}

abstract class $PasswordTooShortErrorCopyWith<$Res> {
  factory $PasswordTooShortErrorCopyWith(PasswordTooShortError value,
          $Res Function(PasswordTooShortError) then) =
      _$PasswordTooShortErrorCopyWithImpl<$Res>;
}

class _$PasswordTooShortErrorCopyWithImpl<$Res>
    extends _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $PasswordTooShortErrorCopyWith<$Res> {
  _$PasswordTooShortErrorCopyWithImpl(
      PasswordTooShortError _value, $Res Function(PasswordTooShortError) _then)
      : super(_value, (v) => _then(v as PasswordTooShortError));

  @override
  PasswordTooShortError get _value => super._value as PasswordTooShortError;
}

class _$PasswordTooShortError implements PasswordTooShortError {
  const _$PasswordTooShortError();

  @override
  String toString() {
    return 'PasswordValidationError.tooShort()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PasswordTooShortError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return tooShort();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooShort != null) {
      return tooShort();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return tooShort(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooShort != null) {
      return tooShort(this);
    }
    return orElse();
  }
}

abstract class PasswordTooShortError implements PasswordValidationError {
  const factory PasswordTooShortError() = _$PasswordTooShortError;
}
