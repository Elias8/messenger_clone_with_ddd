// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'sign_up.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$PasswordStrengthTearOff {
  const _$PasswordStrengthTearOff();

  WeakPasswordStrength weak() {
    return const WeakPasswordStrength();
  }

  GoodPasswordStrength good() {
    return const GoodPasswordStrength();
  }

  StrongPasswordStrength strong() {
    return const StrongPasswordStrength();
  }

  VeryStrongPasswordStrength veryStrong() {
    return const VeryStrongPasswordStrength();
  }
}

// ignore: unused_element
const $PasswordStrength = _$PasswordStrengthTearOff();

mixin _$PasswordStrength {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result weak(),
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result weak(),
    Result good(),
    Result strong(),
    Result veryStrong(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result weak(WeakPasswordStrength value),
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result weak(WeakPasswordStrength value),
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    @required Result orElse(),
  });
}

abstract class $PasswordStrengthCopyWith<$Res> {
  factory $PasswordStrengthCopyWith(
          PasswordStrength value, $Res Function(PasswordStrength) then) =
      _$PasswordStrengthCopyWithImpl<$Res>;
}

class _$PasswordStrengthCopyWithImpl<$Res>
    implements $PasswordStrengthCopyWith<$Res> {
  _$PasswordStrengthCopyWithImpl(this._value, this._then);

  final PasswordStrength _value;
  // ignore: unused_field
  final $Res Function(PasswordStrength) _then;
}

abstract class $WeakPasswordStrengthCopyWith<$Res> {
  factory $WeakPasswordStrengthCopyWith(WeakPasswordStrength value,
          $Res Function(WeakPasswordStrength) then) =
      _$WeakPasswordStrengthCopyWithImpl<$Res>;
}

class _$WeakPasswordStrengthCopyWithImpl<$Res>
    extends _$PasswordStrengthCopyWithImpl<$Res>
    implements $WeakPasswordStrengthCopyWith<$Res> {
  _$WeakPasswordStrengthCopyWithImpl(
      WeakPasswordStrength _value, $Res Function(WeakPasswordStrength) _then)
      : super(_value, (v) => _then(v as WeakPasswordStrength));

  @override
  WeakPasswordStrength get _value => super._value as WeakPasswordStrength;
}

class _$WeakPasswordStrength implements WeakPasswordStrength {
  const _$WeakPasswordStrength();

  @override
  String toString() {
    return 'PasswordStrength.weak()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WeakPasswordStrength);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result weak(),
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
  }) {
    assert(weak != null);
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    return weak();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result weak(),
    Result good(),
    Result strong(),
    Result veryStrong(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (weak != null) {
      return weak();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result weak(WeakPasswordStrength value),
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
  }) {
    assert(weak != null);
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    return weak(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result weak(WeakPasswordStrength value),
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (weak != null) {
      return weak(this);
    }
    return orElse();
  }
}

abstract class WeakPasswordStrength implements PasswordStrength {
  const factory WeakPasswordStrength() = _$WeakPasswordStrength;
}

abstract class $GoodPasswordStrengthCopyWith<$Res> {
  factory $GoodPasswordStrengthCopyWith(GoodPasswordStrength value,
          $Res Function(GoodPasswordStrength) then) =
      _$GoodPasswordStrengthCopyWithImpl<$Res>;
}

class _$GoodPasswordStrengthCopyWithImpl<$Res>
    extends _$PasswordStrengthCopyWithImpl<$Res>
    implements $GoodPasswordStrengthCopyWith<$Res> {
  _$GoodPasswordStrengthCopyWithImpl(
      GoodPasswordStrength _value, $Res Function(GoodPasswordStrength) _then)
      : super(_value, (v) => _then(v as GoodPasswordStrength));

  @override
  GoodPasswordStrength get _value => super._value as GoodPasswordStrength;
}

class _$GoodPasswordStrength implements GoodPasswordStrength {
  const _$GoodPasswordStrength();

  @override
  String toString() {
    return 'PasswordStrength.good()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is GoodPasswordStrength);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result weak(),
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
  }) {
    assert(weak != null);
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    return good();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result weak(),
    Result good(),
    Result strong(),
    Result veryStrong(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (good != null) {
      return good();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result weak(WeakPasswordStrength value),
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
  }) {
    assert(weak != null);
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    return good(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result weak(WeakPasswordStrength value),
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (good != null) {
      return good(this);
    }
    return orElse();
  }
}

abstract class GoodPasswordStrength implements PasswordStrength {
  const factory GoodPasswordStrength() = _$GoodPasswordStrength;
}

abstract class $StrongPasswordStrengthCopyWith<$Res> {
  factory $StrongPasswordStrengthCopyWith(StrongPasswordStrength value,
          $Res Function(StrongPasswordStrength) then) =
      _$StrongPasswordStrengthCopyWithImpl<$Res>;
}

class _$StrongPasswordStrengthCopyWithImpl<$Res>
    extends _$PasswordStrengthCopyWithImpl<$Res>
    implements $StrongPasswordStrengthCopyWith<$Res> {
  _$StrongPasswordStrengthCopyWithImpl(StrongPasswordStrength _value,
      $Res Function(StrongPasswordStrength) _then)
      : super(_value, (v) => _then(v as StrongPasswordStrength));

  @override
  StrongPasswordStrength get _value => super._value as StrongPasswordStrength;
}

class _$StrongPasswordStrength implements StrongPasswordStrength {
  const _$StrongPasswordStrength();

  @override
  String toString() {
    return 'PasswordStrength.strong()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is StrongPasswordStrength);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result weak(),
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
  }) {
    assert(weak != null);
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    return strong();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result weak(),
    Result good(),
    Result strong(),
    Result veryStrong(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (strong != null) {
      return strong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result weak(WeakPasswordStrength value),
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
  }) {
    assert(weak != null);
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    return strong(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result weak(WeakPasswordStrength value),
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (strong != null) {
      return strong(this);
    }
    return orElse();
  }
}

abstract class StrongPasswordStrength implements PasswordStrength {
  const factory StrongPasswordStrength() = _$StrongPasswordStrength;
}

abstract class $VeryStrongPasswordStrengthCopyWith<$Res> {
  factory $VeryStrongPasswordStrengthCopyWith(VeryStrongPasswordStrength value,
          $Res Function(VeryStrongPasswordStrength) then) =
      _$VeryStrongPasswordStrengthCopyWithImpl<$Res>;
}

class _$VeryStrongPasswordStrengthCopyWithImpl<$Res>
    extends _$PasswordStrengthCopyWithImpl<$Res>
    implements $VeryStrongPasswordStrengthCopyWith<$Res> {
  _$VeryStrongPasswordStrengthCopyWithImpl(VeryStrongPasswordStrength _value,
      $Res Function(VeryStrongPasswordStrength) _then)
      : super(_value, (v) => _then(v as VeryStrongPasswordStrength));

  @override
  VeryStrongPasswordStrength get _value =>
      super._value as VeryStrongPasswordStrength;
}

class _$VeryStrongPasswordStrength implements VeryStrongPasswordStrength {
  const _$VeryStrongPasswordStrength();

  @override
  String toString() {
    return 'PasswordStrength.veryStrong()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is VeryStrongPasswordStrength);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result weak(),
    @required Result good(),
    @required Result strong(),
    @required Result veryStrong(),
  }) {
    assert(weak != null);
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    return veryStrong();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result weak(),
    Result good(),
    Result strong(),
    Result veryStrong(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (veryStrong != null) {
      return veryStrong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result weak(WeakPasswordStrength value),
    @required Result good(GoodPasswordStrength value),
    @required Result strong(StrongPasswordStrength value),
    @required Result veryStrong(VeryStrongPasswordStrength value),
  }) {
    assert(weak != null);
    assert(good != null);
    assert(strong != null);
    assert(veryStrong != null);
    return veryStrong(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result weak(WeakPasswordStrength value),
    Result good(GoodPasswordStrength value),
    Result strong(StrongPasswordStrength value),
    Result veryStrong(VeryStrongPasswordStrength value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (veryStrong != null) {
      return veryStrong(this);
    }
    return orElse();
  }
}

abstract class VeryStrongPasswordStrength implements PasswordStrength {
  const factory VeryStrongPasswordStrength() = _$VeryStrongPasswordStrength;
}

class _$SignUpFailureTearOff {
  const _$SignUpFailureTearOff();

  SignUpServerError serverError() {
    return const SignUpServerError();
  }

  EmailAlreadyInUseError emailAlreadyInUse() {
    return const EmailAlreadyInUseError();
  }
}

// ignore: unused_element
const $SignUpFailure = _$SignUpFailureTearOff();

mixin _$SignUpFailure {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result serverError(),
    Result emailAlreadyInUse(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result serverError(SignUpServerError value),
    @required Result emailAlreadyInUse(EmailAlreadyInUseError value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result serverError(SignUpServerError value),
    Result emailAlreadyInUse(EmailAlreadyInUseError value),
    @required Result orElse(),
  });
}

abstract class $SignUpFailureCopyWith<$Res> {
  factory $SignUpFailureCopyWith(
          SignUpFailure value, $Res Function(SignUpFailure) then) =
      _$SignUpFailureCopyWithImpl<$Res>;
}

class _$SignUpFailureCopyWithImpl<$Res>
    implements $SignUpFailureCopyWith<$Res> {
  _$SignUpFailureCopyWithImpl(this._value, this._then);

  final SignUpFailure _value;
  // ignore: unused_field
  final $Res Function(SignUpFailure) _then;
}

abstract class $SignUpServerErrorCopyWith<$Res> {
  factory $SignUpServerErrorCopyWith(
          SignUpServerError value, $Res Function(SignUpServerError) then) =
      _$SignUpServerErrorCopyWithImpl<$Res>;
}

class _$SignUpServerErrorCopyWithImpl<$Res>
    extends _$SignUpFailureCopyWithImpl<$Res>
    implements $SignUpServerErrorCopyWith<$Res> {
  _$SignUpServerErrorCopyWithImpl(
      SignUpServerError _value, $Res Function(SignUpServerError) _then)
      : super(_value, (v) => _then(v as SignUpServerError));

  @override
  SignUpServerError get _value => super._value as SignUpServerError;
}

class _$SignUpServerError implements SignUpServerError {
  const _$SignUpServerError();

  @override
  String toString() {
    return 'SignUpFailure.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SignUpServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
  }) {
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    return serverError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result serverError(),
    Result emailAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result serverError(SignUpServerError value),
    @required Result emailAlreadyInUse(EmailAlreadyInUseError value),
  }) {
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result serverError(SignUpServerError value),
    Result emailAlreadyInUse(EmailAlreadyInUseError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class SignUpServerError implements SignUpFailure {
  const factory SignUpServerError() = _$SignUpServerError;
}

abstract class $EmailAlreadyInUseErrorCopyWith<$Res> {
  factory $EmailAlreadyInUseErrorCopyWith(EmailAlreadyInUseError value,
          $Res Function(EmailAlreadyInUseError) then) =
      _$EmailAlreadyInUseErrorCopyWithImpl<$Res>;
}

class _$EmailAlreadyInUseErrorCopyWithImpl<$Res>
    extends _$SignUpFailureCopyWithImpl<$Res>
    implements $EmailAlreadyInUseErrorCopyWith<$Res> {
  _$EmailAlreadyInUseErrorCopyWithImpl(EmailAlreadyInUseError _value,
      $Res Function(EmailAlreadyInUseError) _then)
      : super(_value, (v) => _then(v as EmailAlreadyInUseError));

  @override
  EmailAlreadyInUseError get _value => super._value as EmailAlreadyInUseError;
}

class _$EmailAlreadyInUseError implements EmailAlreadyInUseError {
  const _$EmailAlreadyInUseError();

  @override
  String toString() {
    return 'SignUpFailure.emailAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmailAlreadyInUseError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result serverError(),
    @required Result emailAlreadyInUse(),
  }) {
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    return emailAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result serverError(),
    Result emailAlreadyInUse(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result serverError(SignUpServerError value),
    @required Result emailAlreadyInUse(EmailAlreadyInUseError value),
  }) {
    assert(serverError != null);
    assert(emailAlreadyInUse != null);
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result serverError(SignUpServerError value),
    Result emailAlreadyInUse(EmailAlreadyInUseError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class EmailAlreadyInUseError implements SignUpFailure {
  const factory EmailAlreadyInUseError() = _$EmailAlreadyInUseError;
}

class _$SignUpFormTearOff {
  const _$SignUpFormTearOff();

  _SignUpForm call(
      {@required Name firstName,
      @required Name lastName,
      @required Password password,
      @required EmailAddress emailAddress,
      @required PasswordConfirmation passwordConfirmation}) {
    return _SignUpForm(
      firstName: firstName,
      lastName: lastName,
      password: password,
      emailAddress: emailAddress,
      passwordConfirmation: passwordConfirmation,
    );
  }
}

// ignore: unused_element
const $SignUpForm = _$SignUpFormTearOff();

mixin _$SignUpForm {
  Name get firstName;
  Name get lastName;
  Password get password;
  EmailAddress get emailAddress;
  PasswordConfirmation get passwordConfirmation;

  $SignUpFormCopyWith<SignUpForm> get copyWith;
}

abstract class $SignUpFormCopyWith<$Res> {
  factory $SignUpFormCopyWith(
          SignUpForm value, $Res Function(SignUpForm) then) =
      _$SignUpFormCopyWithImpl<$Res>;
  $Res call(
      {Name firstName,
      Name lastName,
      Password password,
      EmailAddress emailAddress,
      PasswordConfirmation passwordConfirmation});
}

class _$SignUpFormCopyWithImpl<$Res> implements $SignUpFormCopyWith<$Res> {
  _$SignUpFormCopyWithImpl(this._value, this._then);

  final SignUpForm _value;
  // ignore: unused_field
  final $Res Function(SignUpForm) _then;

  @override
  $Res call({
    Object firstName = freezed,
    Object lastName = freezed,
    Object password = freezed,
    Object emailAddress = freezed,
    Object passwordConfirmation = freezed,
  }) {
    return _then(_value.copyWith(
      firstName: firstName == freezed ? _value.firstName : firstName as Name,
      lastName: lastName == freezed ? _value.lastName : lastName as Name,
      password: password == freezed ? _value.password : password as Password,
      emailAddress: emailAddress == freezed
          ? _value.emailAddress
          : emailAddress as EmailAddress,
      passwordConfirmation: passwordConfirmation == freezed
          ? _value.passwordConfirmation
          : passwordConfirmation as PasswordConfirmation,
    ));
  }
}

abstract class _$SignUpFormCopyWith<$Res> implements $SignUpFormCopyWith<$Res> {
  factory _$SignUpFormCopyWith(
          _SignUpForm value, $Res Function(_SignUpForm) then) =
      __$SignUpFormCopyWithImpl<$Res>;
  @override
  $Res call(
      {Name firstName,
      Name lastName,
      Password password,
      EmailAddress emailAddress,
      PasswordConfirmation passwordConfirmation});
}

class __$SignUpFormCopyWithImpl<$Res> extends _$SignUpFormCopyWithImpl<$Res>
    implements _$SignUpFormCopyWith<$Res> {
  __$SignUpFormCopyWithImpl(
      _SignUpForm _value, $Res Function(_SignUpForm) _then)
      : super(_value, (v) => _then(v as _SignUpForm));

  @override
  _SignUpForm get _value => super._value as _SignUpForm;

  @override
  $Res call({
    Object firstName = freezed,
    Object lastName = freezed,
    Object password = freezed,
    Object emailAddress = freezed,
    Object passwordConfirmation = freezed,
  }) {
    return _then(_SignUpForm(
      firstName: firstName == freezed ? _value.firstName : firstName as Name,
      lastName: lastName == freezed ? _value.lastName : lastName as Name,
      password: password == freezed ? _value.password : password as Password,
      emailAddress: emailAddress == freezed
          ? _value.emailAddress
          : emailAddress as EmailAddress,
      passwordConfirmation: passwordConfirmation == freezed
          ? _value.passwordConfirmation
          : passwordConfirmation as PasswordConfirmation,
    ));
  }
}

class _$_SignUpForm implements _SignUpForm {
  const _$_SignUpForm(
      {@required this.firstName,
      @required this.lastName,
      @required this.password,
      @required this.emailAddress,
      @required this.passwordConfirmation})
      : assert(firstName != null),
        assert(lastName != null),
        assert(password != null),
        assert(emailAddress != null),
        assert(passwordConfirmation != null);

  @override
  final Name firstName;
  @override
  final Name lastName;
  @override
  final Password password;
  @override
  final EmailAddress emailAddress;
  @override
  final PasswordConfirmation passwordConfirmation;

  @override
  String toString() {
    return 'SignUpForm(firstName: $firstName, lastName: $lastName, password: $password, emailAddress: $emailAddress, passwordConfirmation: $passwordConfirmation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SignUpForm &&
            (identical(other.firstName, firstName) ||
                const DeepCollectionEquality()
                    .equals(other.firstName, firstName)) &&
            (identical(other.lastName, lastName) ||
                const DeepCollectionEquality()
                    .equals(other.lastName, lastName)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.passwordConfirmation, passwordConfirmation) ||
                const DeepCollectionEquality()
                    .equals(other.passwordConfirmation, passwordConfirmation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(firstName) ^
      const DeepCollectionEquality().hash(lastName) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(passwordConfirmation);

  @override
  _$SignUpFormCopyWith<_SignUpForm> get copyWith =>
      __$SignUpFormCopyWithImpl<_SignUpForm>(this, _$identity);
}

abstract class _SignUpForm implements SignUpForm {
  const factory _SignUpForm(
      {@required Name firstName,
      @required Name lastName,
      @required Password password,
      @required EmailAddress emailAddress,
      @required PasswordConfirmation passwordConfirmation}) = _$_SignUpForm;

  @override
  Name get firstName;
  @override
  Name get lastName;
  @override
  Password get password;
  @override
  EmailAddress get emailAddress;
  @override
  PasswordConfirmation get passwordConfirmation;
  @override
  _$SignUpFormCopyWith<_SignUpForm> get copyWith;
}

class _$EmailValidationErrorTearOff {
  const _$EmailValidationErrorTearOff();

  EmptyEmailAdress empty() {
    return const EmptyEmailAdress();
  }

  InvalidEmailAdress invalid() {
    return const InvalidEmailAdress();
  }
}

// ignore: unused_element
const $EmailValidationError = _$EmailValidationErrorTearOff();

mixin _$EmailValidationError {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result invalid(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result invalid(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyEmailAdress value),
    @required Result invalid(InvalidEmailAdress value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyEmailAdress value),
    Result invalid(InvalidEmailAdress value),
    @required Result orElse(),
  });
}

abstract class $EmailValidationErrorCopyWith<$Res> {
  factory $EmailValidationErrorCopyWith(EmailValidationError value,
          $Res Function(EmailValidationError) then) =
      _$EmailValidationErrorCopyWithImpl<$Res>;
}

class _$EmailValidationErrorCopyWithImpl<$Res>
    implements $EmailValidationErrorCopyWith<$Res> {
  _$EmailValidationErrorCopyWithImpl(this._value, this._then);

  final EmailValidationError _value;
  // ignore: unused_field
  final $Res Function(EmailValidationError) _then;
}

abstract class $EmptyEmailAdressCopyWith<$Res> {
  factory $EmptyEmailAdressCopyWith(
          EmptyEmailAdress value, $Res Function(EmptyEmailAdress) then) =
      _$EmptyEmailAdressCopyWithImpl<$Res>;
}

class _$EmptyEmailAdressCopyWithImpl<$Res>
    extends _$EmailValidationErrorCopyWithImpl<$Res>
    implements $EmptyEmailAdressCopyWith<$Res> {
  _$EmptyEmailAdressCopyWithImpl(
      EmptyEmailAdress _value, $Res Function(EmptyEmailAdress) _then)
      : super(_value, (v) => _then(v as EmptyEmailAdress));

  @override
  EmptyEmailAdress get _value => super._value as EmptyEmailAdress;
}

class _$EmptyEmailAdress implements EmptyEmailAdress {
  const _$EmptyEmailAdress();

  @override
  String toString() {
    return 'EmailValidationError.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptyEmailAdress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result invalid(),
  }) {
    assert(empty != null);
    assert(invalid != null);
    return empty();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result invalid(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyEmailAdress value),
    @required Result invalid(InvalidEmailAdress value),
  }) {
    assert(empty != null);
    assert(invalid != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyEmailAdress value),
    Result invalid(InvalidEmailAdress value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyEmailAdress implements EmailValidationError {
  const factory EmptyEmailAdress() = _$EmptyEmailAdress;
}

abstract class $InvalidEmailAdressCopyWith<$Res> {
  factory $InvalidEmailAdressCopyWith(
          InvalidEmailAdress value, $Res Function(InvalidEmailAdress) then) =
      _$InvalidEmailAdressCopyWithImpl<$Res>;
}

class _$InvalidEmailAdressCopyWithImpl<$Res>
    extends _$EmailValidationErrorCopyWithImpl<$Res>
    implements $InvalidEmailAdressCopyWith<$Res> {
  _$InvalidEmailAdressCopyWithImpl(
      InvalidEmailAdress _value, $Res Function(InvalidEmailAdress) _then)
      : super(_value, (v) => _then(v as InvalidEmailAdress));

  @override
  InvalidEmailAdress get _value => super._value as InvalidEmailAdress;
}

class _$InvalidEmailAdress implements InvalidEmailAdress {
  const _$InvalidEmailAdress();

  @override
  String toString() {
    return 'EmailValidationError.invalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidEmailAdress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result invalid(),
  }) {
    assert(empty != null);
    assert(invalid != null);
    return invalid();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result invalid(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalid != null) {
      return invalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyEmailAdress value),
    @required Result invalid(InvalidEmailAdress value),
  }) {
    assert(empty != null);
    assert(invalid != null);
    return invalid(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyEmailAdress value),
    Result invalid(InvalidEmailAdress value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalid != null) {
      return invalid(this);
    }
    return orElse();
  }
}

abstract class InvalidEmailAdress implements EmailValidationError {
  const factory InvalidEmailAdress() = _$InvalidEmailAdress;
}

class _$NameValidationErrorTearOff {
  const _$NameValidationErrorTearOff();

  EmptyName empty() {
    return const EmptyName();
  }

  NameTooLong long() {
    return const NameTooLong();
  }

  NameTooShort short() {
    return const NameTooShort();
  }
}

// ignore: unused_element
const $NameValidationError = _$NameValidationErrorTearOff();

mixin _$NameValidationError {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result long(),
    @required Result short(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result long(),
    Result short(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyName value),
    @required Result long(NameTooLong value),
    @required Result short(NameTooShort value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyName value),
    Result long(NameTooLong value),
    Result short(NameTooShort value),
    @required Result orElse(),
  });
}

abstract class $NameValidationErrorCopyWith<$Res> {
  factory $NameValidationErrorCopyWith(
          NameValidationError value, $Res Function(NameValidationError) then) =
      _$NameValidationErrorCopyWithImpl<$Res>;
}

class _$NameValidationErrorCopyWithImpl<$Res>
    implements $NameValidationErrorCopyWith<$Res> {
  _$NameValidationErrorCopyWithImpl(this._value, this._then);

  final NameValidationError _value;
  // ignore: unused_field
  final $Res Function(NameValidationError) _then;
}

abstract class $EmptyNameCopyWith<$Res> {
  factory $EmptyNameCopyWith(EmptyName value, $Res Function(EmptyName) then) =
      _$EmptyNameCopyWithImpl<$Res>;
}

class _$EmptyNameCopyWithImpl<$Res>
    extends _$NameValidationErrorCopyWithImpl<$Res>
    implements $EmptyNameCopyWith<$Res> {
  _$EmptyNameCopyWithImpl(EmptyName _value, $Res Function(EmptyName) _then)
      : super(_value, (v) => _then(v as EmptyName));

  @override
  EmptyName get _value => super._value as EmptyName;
}

class _$EmptyName implements EmptyName {
  const _$EmptyName();

  @override
  String toString() {
    return 'NameValidationError.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptyName);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result long(),
    @required Result short(),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return empty();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result long(),
    Result short(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyName value),
    @required Result long(NameTooLong value),
    @required Result short(NameTooShort value),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyName value),
    Result long(NameTooLong value),
    Result short(NameTooShort value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyName implements NameValidationError {
  const factory EmptyName() = _$EmptyName;
}

abstract class $NameTooLongCopyWith<$Res> {
  factory $NameTooLongCopyWith(
          NameTooLong value, $Res Function(NameTooLong) then) =
      _$NameTooLongCopyWithImpl<$Res>;
}

class _$NameTooLongCopyWithImpl<$Res>
    extends _$NameValidationErrorCopyWithImpl<$Res>
    implements $NameTooLongCopyWith<$Res> {
  _$NameTooLongCopyWithImpl(
      NameTooLong _value, $Res Function(NameTooLong) _then)
      : super(_value, (v) => _then(v as NameTooLong));

  @override
  NameTooLong get _value => super._value as NameTooLong;
}

class _$NameTooLong implements NameTooLong {
  const _$NameTooLong();

  @override
  String toString() {
    return 'NameValidationError.long()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NameTooLong);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result long(),
    @required Result short(),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return long();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result long(),
    Result short(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (long != null) {
      return long();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyName value),
    @required Result long(NameTooLong value),
    @required Result short(NameTooShort value),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return long(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyName value),
    Result long(NameTooLong value),
    Result short(NameTooShort value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (long != null) {
      return long(this);
    }
    return orElse();
  }
}

abstract class NameTooLong implements NameValidationError {
  const factory NameTooLong() = _$NameTooLong;
}

abstract class $NameTooShortCopyWith<$Res> {
  factory $NameTooShortCopyWith(
          NameTooShort value, $Res Function(NameTooShort) then) =
      _$NameTooShortCopyWithImpl<$Res>;
}

class _$NameTooShortCopyWithImpl<$Res>
    extends _$NameValidationErrorCopyWithImpl<$Res>
    implements $NameTooShortCopyWith<$Res> {
  _$NameTooShortCopyWithImpl(
      NameTooShort _value, $Res Function(NameTooShort) _then)
      : super(_value, (v) => _then(v as NameTooShort));

  @override
  NameTooShort get _value => super._value as NameTooShort;
}

class _$NameTooShort implements NameTooShort {
  const _$NameTooShort();

  @override
  String toString() {
    return 'NameValidationError.short()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NameTooShort);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result empty(),
    @required Result long(),
    @required Result short(),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return short();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result empty(),
    Result long(),
    Result short(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (short != null) {
      return short();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result empty(EmptyName value),
    @required Result long(NameTooLong value),
    @required Result short(NameTooShort value),
  }) {
    assert(empty != null);
    assert(long != null);
    assert(short != null);
    return short(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result empty(EmptyName value),
    Result long(NameTooLong value),
    Result short(NameTooShort value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (short != null) {
      return short(this);
    }
    return orElse();
  }
}

abstract class NameTooShort implements NameValidationError {
  const factory NameTooShort() = _$NameTooShort;
}

class _$PasswordValidationErrorTearOff {
  const _$PasswordValidationErrorTearOff();

  PasswordConfirmationError confirmationFailed() {
    return const PasswordConfirmationError();
  }

  EmptyPasswordError empty() {
    return const EmptyPasswordError();
  }

  PasswordTooLogError tooLong() {
    return const PasswordTooLogError();
  }

  PasswordTooShortError tooShort() {
    return const PasswordTooShortError();
  }
}

// ignore: unused_element
const $PasswordValidationError = _$PasswordValidationErrorTearOff();

mixin _$PasswordValidationError {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  });
}

abstract class $PasswordValidationErrorCopyWith<$Res> {
  factory $PasswordValidationErrorCopyWith(PasswordValidationError value,
          $Res Function(PasswordValidationError) then) =
      _$PasswordValidationErrorCopyWithImpl<$Res>;
}

class _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $PasswordValidationErrorCopyWith<$Res> {
  _$PasswordValidationErrorCopyWithImpl(this._value, this._then);

  final PasswordValidationError _value;
  // ignore: unused_field
  final $Res Function(PasswordValidationError) _then;
}

abstract class $PasswordConfirmationErrorCopyWith<$Res> {
  factory $PasswordConfirmationErrorCopyWith(PasswordConfirmationError value,
          $Res Function(PasswordConfirmationError) then) =
      _$PasswordConfirmationErrorCopyWithImpl<$Res>;
}

class _$PasswordConfirmationErrorCopyWithImpl<$Res>
    extends _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $PasswordConfirmationErrorCopyWith<$Res> {
  _$PasswordConfirmationErrorCopyWithImpl(PasswordConfirmationError _value,
      $Res Function(PasswordConfirmationError) _then)
      : super(_value, (v) => _then(v as PasswordConfirmationError));

  @override
  PasswordConfirmationError get _value =>
      super._value as PasswordConfirmationError;
}

class _$PasswordConfirmationError implements PasswordConfirmationError {
  const _$PasswordConfirmationError();

  @override
  String toString() {
    return 'PasswordValidationError.confirmationFailed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PasswordConfirmationError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return confirmationFailed();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (confirmationFailed != null) {
      return confirmationFailed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return confirmationFailed(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (confirmationFailed != null) {
      return confirmationFailed(this);
    }
    return orElse();
  }
}

abstract class PasswordConfirmationError implements PasswordValidationError {
  const factory PasswordConfirmationError() = _$PasswordConfirmationError;
}

abstract class $EmptyPasswordErrorCopyWith<$Res> {
  factory $EmptyPasswordErrorCopyWith(
          EmptyPasswordError value, $Res Function(EmptyPasswordError) then) =
      _$EmptyPasswordErrorCopyWithImpl<$Res>;
}

class _$EmptyPasswordErrorCopyWithImpl<$Res>
    extends _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $EmptyPasswordErrorCopyWith<$Res> {
  _$EmptyPasswordErrorCopyWithImpl(
      EmptyPasswordError _value, $Res Function(EmptyPasswordError) _then)
      : super(_value, (v) => _then(v as EmptyPasswordError));

  @override
  EmptyPasswordError get _value => super._value as EmptyPasswordError;
}

class _$EmptyPasswordError implements EmptyPasswordError {
  const _$EmptyPasswordError();

  @override
  String toString() {
    return 'PasswordValidationError.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmptyPasswordError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return empty();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyPasswordError implements PasswordValidationError {
  const factory EmptyPasswordError() = _$EmptyPasswordError;
}

abstract class $PasswordTooLogErrorCopyWith<$Res> {
  factory $PasswordTooLogErrorCopyWith(
          PasswordTooLogError value, $Res Function(PasswordTooLogError) then) =
      _$PasswordTooLogErrorCopyWithImpl<$Res>;
}

class _$PasswordTooLogErrorCopyWithImpl<$Res>
    extends _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $PasswordTooLogErrorCopyWith<$Res> {
  _$PasswordTooLogErrorCopyWithImpl(
      PasswordTooLogError _value, $Res Function(PasswordTooLogError) _then)
      : super(_value, (v) => _then(v as PasswordTooLogError));

  @override
  PasswordTooLogError get _value => super._value as PasswordTooLogError;
}

class _$PasswordTooLogError implements PasswordTooLogError {
  const _$PasswordTooLogError();

  @override
  String toString() {
    return 'PasswordValidationError.tooLong()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PasswordTooLogError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return tooLong();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooLong != null) {
      return tooLong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return tooLong(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooLong != null) {
      return tooLong(this);
    }
    return orElse();
  }
}

abstract class PasswordTooLogError implements PasswordValidationError {
  const factory PasswordTooLogError() = _$PasswordTooLogError;
}

abstract class $PasswordTooShortErrorCopyWith<$Res> {
  factory $PasswordTooShortErrorCopyWith(PasswordTooShortError value,
          $Res Function(PasswordTooShortError) then) =
      _$PasswordTooShortErrorCopyWithImpl<$Res>;
}

class _$PasswordTooShortErrorCopyWithImpl<$Res>
    extends _$PasswordValidationErrorCopyWithImpl<$Res>
    implements $PasswordTooShortErrorCopyWith<$Res> {
  _$PasswordTooShortErrorCopyWithImpl(
      PasswordTooShortError _value, $Res Function(PasswordTooShortError) _then)
      : super(_value, (v) => _then(v as PasswordTooShortError));

  @override
  PasswordTooShortError get _value => super._value as PasswordTooShortError;
}

class _$PasswordTooShortError implements PasswordTooShortError {
  const _$PasswordTooShortError();

  @override
  String toString() {
    return 'PasswordValidationError.tooShort()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PasswordTooShortError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result confirmationFailed(),
    @required Result empty(),
    @required Result tooLong(),
    @required Result tooShort(),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return tooShort();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result confirmationFailed(),
    Result empty(),
    Result tooLong(),
    Result tooShort(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooShort != null) {
      return tooShort();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result confirmationFailed(PasswordConfirmationError value),
    @required Result empty(EmptyPasswordError value),
    @required Result tooLong(PasswordTooLogError value),
    @required Result tooShort(PasswordTooShortError value),
  }) {
    assert(confirmationFailed != null);
    assert(empty != null);
    assert(tooLong != null);
    assert(tooShort != null);
    return tooShort(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result confirmationFailed(PasswordConfirmationError value),
    Result empty(EmptyPasswordError value),
    Result tooLong(PasswordTooLogError value),
    Result tooShort(PasswordTooShortError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tooShort != null) {
      return tooShort(this);
    }
    return orElse();
  }
}

abstract class PasswordTooShortError implements PasswordValidationError {
  const factory PasswordTooShortError() = _$PasswordTooShortError;
}
